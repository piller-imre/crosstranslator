\Chapter{Szintaktikai elemzés}

% TODO: Formális nyelvekkel, fordítóprogramokkal kapcsolatos könyvek hivatkozásai.

% http://www.informatik.uni-bremen.de/agbkb/lehre/ccfl/Material/ALSUdragonbook.pdf

\section{Java parser generátorok}

Az Interneten különféle parser generátorokat találhatunk, amelyek segítségével könnyebben megoldható a szintaktikai elemzés.
A feladat megoldásához olyan parser generátorra van szükség, mely Java nyelvű, mivel a fordítóprogram ezen a nyelven kerül megírása.
Továbbá, a parser generátorok feldolgozás szempontjából is különböznek, és jelen feladathoz olyan generátort kellett keresni, mely reguláris nyelvvel képes működni.
Az alábbiakban néhány, elterjedt generátort vizsgálunk meg.

\subsection{AnnoFlex}

Az \textit{Annoflex} egy Java alapú generátor, mely szabadon letölthető és használható, sőt módosítható is.
Az AnnoFlex tervezésekor törekedtek az egyszerűségre. A következő kódrészletben láthatunk egy példát a használati módjára.
\begin{java}
/**
* @option methodName = getNextToken
* @option statistics = enabled
*/
public class Example_Annoflex {
/** @expr [0-9]+       */ String createNumber()     { return "number"; }
/** @expr [a-zA-Z]+    */ String createIdentifier() { return "identifier"; }
/** @expr [ \n\r\t\f]+ */ String createWhitespace() { return "whitespace"; }
//%%LEX-MAIN-START%%
//%%LEX-MAIN-END%%
}
\end{java}

A generátornak Java kommentekben adhatjuk meg a nyelv elemeire vonatkozó beállításokat az osztály és a metódus definíciók előtt. Az osztályra vonatkozó beállításokat \texttt{@option} formában használhatjuk. Az előző kódpéldában egyrészt a következő token beolvasásához szükséges metódus nevét adtuk meg, illetve, hogy a nyelvi feldolgozó generálása közben készítsen-e majd statisztikát a program.

Ezt követően az osztályon belül meg kell adni a kifejezéseket és a metódusokat. Itt találkozhatunk több megkötéssel is az AnnoFlex tekintetében. A megadáskor mindenképpen \texttt{@expr} kifejezéssel kell kezdeni, melyet szintén kommentben kell elhelyezni.

A kifejezés után csak és kizárólag reguláris kifejezés állhat. A komment után magát a metódust kell megírni, melynél szintén van megkötés. A metódusok nem lehetnek \texttt{static} módosítóval ellátva, visszatérési értékük nem lehet csak primitív típus vagy \texttt{String}, de mindenképpen az összes így megadott metódusnak ugyanolyan visszatérési értékkel kell bírnia, egyetlen kivétellel, ami a \texttt{void}. \texttt{void} visszatérési érték állhat más visszetérési érték mellett. További megkötés, hogy a metódusoknak nem lehet paraméterük, csak visszatérési értékük.

Minden egyes metódust csak egy darab reguláris kifejezés előzhet meg, ha több reguláris kifejezés is kellene, hogy ott álljon, akkor a reguláris kifejezések uniójával oldható ez meg, melyhez a \texttt{|} operátor használható.

Ez után következik egy tagek által határolt üres rész, ezt mindig a
\begin{java}
//%%LEX-MAIN-START%%
//%%LEX-MAIN-END%%
\end{java}
sorok határolják, és ide kerül legenerálásra magának a nyelvi feldolgozónak a kódja.

Amennyiben elkészültünk a kifejezések megírásával, akkor a fejlesztőkörnyezetben lefuttathatjuk a AnnoFlex programot.

% TODO: Itt csak behivatkozni majd valahogy a generált kódot, és csak néhány érdekesebb kódrészt mutatni belőle!

% TODO: Fel lehet sorolni a generált adattagokat és metódusokat!

% A fenti kódban látható, hogy a program legenerálta a szükséges metódusokat és funkciókat.
Ezután már nem kell mást tenni, mint egy futtatható osztályt készíteni a példához:

\begin{java}
public class Example_AnnoRun {

	public static void main(String[] args) {
		Example_Annoflex anno = new Example_Annoflex();
		anno.setString("Ez 1 teszt string");
		System.out.println("Scan:" + anno.getString());
		String token = anno.getNextToken();
		while (token != null) {
			System.out.println(token + ":" + anno.getMatchText());
			token = anno.getNextToken();
		}
	}

}
\end{java}

Ebben csak létrehozunk egy példányt az osztályból, hozzáadunk egy szöveget és lefuttatjuk a programot. A képernyőre a következő eredményt fogja a program kiírni:

\begin{verbatim}
Scan:Ez 1 teszt string
identifier:Ez
whitespace: 
number:1
whitespace: 
identifier:teszt
whitespace: 
identifier:string
\end{verbatim}

Látható, hogy \texttt{identifier}-nek jelezte a szövegeket, a számot numberként jelenítette meg és megtalálta a fehér karaktereket is, azaz a szóközöket.

\subsection{JFlex}

A \textit{JFlex} szigorú értelembe véve egy lexikai elemző, azaz lexer generátor, mely Java nyelvhez Java nyelven írt generátor. Itt is a megadott inputot próbálja meg illeszteni a különféle előre definiált nyelvtani elemekre és az annak megfelelő utasításokat hajtja végre.

A JFlex a \textit{JLex} átírt változata, melynek átírásakor a cél a teljes unicode támogatás és platformfüggetlenség volt, illetve a gyors szkenner generálás, kényelmes szintaktika és az is, hogy kompatibilis legyen a JLex-el. Önállóan is használható, de mivel főképp lexer generátor, így más parser generátorokkal történő együttműködésre tervezték, leginkább a CUP parserrel kompatibilis.

Felépítése alapján a nyelvtani specifikáció három részre osztható, melyeket a \texttt{\%\%} jel választ el. Az első a felhasználói kód, a második a beállítások és makrók része, míg a harmadik fogja tartalmazni a lexer szabályokat.

% TODO: Itt is csak említeni kellene a példával kapcsolatban néhány észrevételt!

\subsection{AustenX}

Az \textit{AustenX} (vagy röviden csak \textit{Austen}) szinten egy parser generátor. Az Austen jelenleg csak Java nyelvet támogatja, és az előzőekhez hasonlóan ez is reguláris nyelv alapján dolgozza fel a kódot.

Az Austin egy \texttt{jar} fájlként tölthető le és futtatható, aminek futtatásakor paraméterként kell megadni a célfájlt. Az Austen futtatható a jar fájlra kattintva duplán, ilyenkor egy egyszerű felhasználói kezelőfelület nyílik meg. Itt meg kell adni a forrásfájlok helyét, amiben a feldolgozáshoz szükséges adatok vannak, illetve a célfájl helyét, ahova a feldolgozott fájlok kerülnek. A forrásfájlok .austen vagy .austenx kiterjesztéssel kell, hogy rendelkezzenek. Az alábbiakban egy egyszerűbb példa látható a forrásfájlokra.

% TODO: Tömören össze kellene foglalni a generált kódot.

A generált kód egy általános leírást tartalmaz, library-k szerint szervezve melyet felhasznál az alábbi kód, ami a parser generator pontos leírását tartalmazza.
